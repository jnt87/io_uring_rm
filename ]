use io_uring::{
    IoUring,
    opcode,
    types,
};
use std::{
    collections::VecDeque,
    ffi::{CString, CStr, c_char},
    process,
    path::Path,
    fs,
    fs::OpenOptions,
    io,
    os::unix::io::AsRawFd,
    sync::{Arc, atomic::{AtomicBool, Ordering}},
    thread,
    time::Duration,
};
use signal_hook::iterator::Signals;
use libc::{dirent64, AT_REMOVEDIR, AT_FDCWD, O_RDONLY, unlinkat, access, F_OK}; //want to add O_TRUNC as a fast mode if we
                                                        //think we will replace files

macro_rules! trust_me_bro {
    ($($stmt:stmt;)*) => {
        unsafe {
            $($stmt)*
        }
    };
}

fn list_dir(path: &str) -> io::Result<Vec<String>> {
    let mut entries = Vec::new();

    for entry in fs::read_dir(Path::new(path))? {
        let entry = entry?;
        let path_buf = entry.path();
        if let Some(path_str) = path_buf.to_str() {
            entries.push(path_str.to_string());
        }
    }
    Ok(entries)
}

fn list_dir2(path: &str) -> io::Result<Vec<String>> {
    let dir = OpenOptions::new().read(true).open(path)?;
    let fd = dir.as_raw_fd();
    let mut buf = vec![0; 4096];
    let mut entries = Vec::new();
    unsafe {
        let nread = libc::syscall(libc::SYS_getdents64, fd, buf.as_mut_ptr(), buf.len()) as isize;
        if nread < 0 {
            return Err(io::Error::last_os_error());
        }
        let mut offset = 0;
        while offset < nread as usize { 
            println!("list_dir while loop");
            let d = &*(buf.as_ptr().add(offset) as *const dirent64);

            if d.d_reclen == 0 {
                break;
            }
            let name_bytes = &d.d_name;
            let name_cstr = CStr::from_ptr(name_bytes.as_ptr().cast());
            let name = name_cstr.to_string_lossy().into_owned();
            println!("Name: {}", name);
            if name != "." && name != ".." {
                entries.push(format!("{}/{}", path, name));
            }
            offset += d.d_reclen as usize;
            println!("offset: {} and d_reclen: {}", offset, d.d_reclen);
        }
    };
    Ok(entries)
}

fn delete_directory_iteratively(root_path: &str, ring: &mut IoUring) {
    let mut queue = Box::new(VecDeque::new());
    queue.push_back(root_path.to_string());

    let mut file_deletions: Vec<String> = Vec::new();
    let mut dir_deletions: Vec<String> = Vec::new();
    println!("Path: {}", root_path);
    while let Some(path) = queue.pop_front() {
        match list_dir(&path) {
            Ok(entries) => {
                for entry in entries {
                    match std::fs::metadata(&entry) {
                        Ok(metadata) => {
                            if metadata.is_dir() {
                                println!("Adding dir: {} to be checked", entry);
                                queue.push_back(entry);
                            } else {
                                println!("Adding file: {} to be deleted", entry);
                                file_deletions.push(entry);
                            }
                        }
                        Err(e) => {
                            eprintln!("Warning: Could not access '{}': {}", entry, e);
                        }
                    }
                }
                dir_deletions.push(path);
            }
            Err(err) => {
                eprintln!("Failed to list '{}': {}", path, err);
            }
        }
    }
    {
        let mut counter = 0;
        let mut sq = ring.submission();
        for file in file_deletions {
            let c_file = match CString::new(file.replace("\0", "")) {
                Ok(c) => c,
                Err(e) => {
                    eprintln!("Failed to convert path to CString: {:?}", file);
                    continue;
                }
            };
            if !Path::new(&file).exists() {
                eprintln!("found file does not exists");
            }
            let exists = Path::new(&file).exists();
            if exists {
                println!("File exists");
            } else {
                println!("File does not exit");
            }
            let c_ptr: *const c_char = c_file.as_ptr();
            let exists = unsafe { access(c_ptr, F_OK) == 0};
            if exists {
                println!("CFile exists");
            } else {
                println!("CFile does not exit");
            }

            println!("c_ptr: {:?}", c_ptr);
            let entry = opcode::UnlinkAt::new(types::Fd(AT_FDCWD), c_ptr)
                .build()
                .user_data(counter);
            counter += 1;

            println!("Submitting request Unlinking {:?}", file);
            unsafe {
                let _ = sq.push(&entry); //dont ignore
            }
        }
    }
/*    {
        let mut counter = 0;
        let mut sq = ring.submission();
        for dir in dir_deletions.into_iter().rev() {
            let c_dir = match CString::new(dir.replace("\0", "")) {
                Ok(c) => c,
                Err(_) => {
                    println!("Failed to convert path ot CString: {:?}", dir);
                    continue;
                }
            };
            if !Path::new(&dir).exists() {
                eprintln!("found dir does not exists");
            }
            let c_ptr: *const c_char = c_dir.as_ptr();
            let entry = opcode::UnlinkAt::new(types::Fd(AT_FDCWD), c_ptr)
                .flags(AT_REMOVEDIR)
                .build()
                .user_data(counter);
            counter += 1;
            println!("Submitting request Removing directory {:?}", dir);
            unsafe {
                let _ = sq.push(&entry);
            }
        }
    }*/
}

fn handle_signals(signals: Vec<i32>, running: Arc<AtomicBool>) {
    let mut signals = Signals::new(&signals).expect("Failed to register signals");

    thread::spawn(move || {
        for signal in signals.forever() {
            println!("Recieved signal: {}", signal);
            running.store(false, Ordering::Relaxed);
            break;
        }
    });

}

fn wait_for_io_uring(ring: &mut IoUring, running: &Arc<AtomicBool>) {
    while running.load(Ordering::Relaxed) {
        println!("wait_for_io_uring while loop");
        /*if ring.submission().is_empty() {
            println!("ring was empty");
            let timespec = types::Timespec::from(Duration::from_secs(3));
            let timeout_entry = opcode::Timeout::new(&timespec).build().user_data(999);

            {
                let mut sq = ring.submission();
                unsafe {
                    let _ = sq.push(&timeout_entry);
                }
                drop(sq);
            }
        }*/

        match ring.submit_and_wait(1) {
            Ok(_) => {
                let mut cq = ring.completion();
                let mut found = false;
                while let Some(cqe) = cq.next() {
                    found = true;
                    println!("submit and wait while loop");
                    if cqe.user_data() == 999 {
                        println!("No pending operations, exiting.");
                        return;
                    }
                    if cqe.result() < 0 {
                        println!("User data: {} Result: {}", cqe.user_data(), cqe.result());
                        println!("Error: {}", std::io::Error::from_raw_os_error(-cqe.result()));
                    }
                }
                if !found {
                    println!("No completion events received, breaking loop.");
                    break;
                }
            }
            Err(e) => {
                eprintln!("Error waiting for completion: {}", e);
                break;
            }
        }
    }

    if !running.load(Ordering::Relaxed) {
        eprintln!("\nOperation interrupted. Exiting.");
        process::exit(130);
    }
}

fn main() {
    println!("Started rm");
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 3 {
        eprintln!("Usage: {} <file>", args[0]);
        process::exit(1);
    }

    let path = &args[1];
    let dir = &args[1];
    let mut c_path;
    let metadata = match std::fs::metadata(path) {
        Ok(meta) => meta,
        Err(err) => {
            eprintln!("Failed to access '{}': {}", path, err);
            process::exit(1);
        }
    };
    
    if metadata.is_dir() {
        let entries = list_dir(path).unwrap();
        println!("Entries: {:?}", entries);
    }

    println!("Checked arg");

    let mut ring = IoUring::new(8).expect("Failed to create io_uring");

    println!("created io_uring");
    let running = Arc::new(AtomicBool::new(true));
    let signals = vec![libc::SIGINT, libc::SIGTERM, libc::SIGHUP];

    handle_signals(signals, running.clone());
//    if metadata.is_dir() {
    if false {
        delete_directory_iteratively(path, &mut ring);
    } else {
        let vector = list_dir(dir).unwrap(*)
        println!("just a file...");
        println!("check1: {}", path.to_string());
        println!("check2: {:?}", list_dir(dir).unwrap());
        let index = list_dir(dir).unwrap().iter().position(|s| s == path.to_string())
        c_path = CString::new(path.to_string()).unwrap(); //bad
        let entry = opcode::UnlinkAt::new(types::Fd(libc::AT_FDCWD), c_path.as_ptr())
            .build()
            .user_data(42);
        let mut sq = ring.submission();
        unsafe {
            sq.push(&entry).expect("Submission queue is full");
        }
        drop(sq);
    }
    //wait_for_io_uring(&mut ring, &running);
/*    ring.submit_and_wait(1);
    let cq = ring.completion();

    for cqe in cq {
        if cqe.user_data() == 42 {
            println!("user data match");
            let res = cqe.result();
            if res < 0 {
                eprintln!("Unlink failed with error: {}", -res);
            } else {
                println!("Filed deleted sucessfully");
            }
        }
    }*/
/*    let c_path = CString::new(path.to_string()).unwrap();

    let unlink_e = opcode::UnlinkAt::new(types::Fd(libc::AT_FDCWD), c_path.as_ptr())
        .build()
        .user_data(42);

    let mut sq = ring.submission();

    unsafe {
        sq.push(&unlink_e).expect("Submission queue is full");
    }
    drop(sq);
*/
    println!("Forward progress");
    ring.submit_and_wait(1).expect("submit and wait failed");

    let cq = ring.completion();

    for cqe in cq {
        let res = cqe.result();
        if res < 0 {
            eprintln!("Unlink failed with error: {}", -res);
        } else {
            println!("File deleted successfully!");
        }
    }
}
